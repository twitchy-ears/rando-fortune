;;; rando-fortune.el --- Load a random fortune from a file or directory without needing fortune(1) -*- lexical-binding: t -*-

;; Copyright 2024 - Twitchy Ears

;; Author: Twitchy Ears https://github.com/twitchy-ears/
;; URL: https://github.com/twitchy-ears/rando-fortune
;; Version: 0.2
;; Package-Requires ((emacs "24.3"))
;; Keywords: games

;; This file is not part of GNU Emacs.

;; This program is free software; you can redistribute it and/or
;; modify it under the terms of the GNU General Public License as
;; published by the Free Software Foundation; either version 3, or
;; (at your option) any later version.
;;
;; This program is distributed in the hope that it will be useful,
;; but WITHOUT ANY WARRANTY; without even the implied warranty of
;; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
;; General Public License for more details.
;;
;; You should have received a copy of the GNU General Public License
;; along with this program; see the file COPYING.  If not, write to
;; the Free Software Foundation, Inc., 51 Franklin Street, Fifth
;; Floor, Boston, MA 02110-1301, USA.

;;; History
;;
;; 2024-01-22 - initial version
;; 2024-01-23 - tidy up, now does caching and understands directories

;;; Commentary:

;; (require 'rando-fortune)
;;
;; ;; Set location to a single file
;; (setq fortune-file "~/.fortunes/quotes")
;;
;; ;; Set location to a whole directory, file is prioritised
;; (setq fortune-dir "~/.fortunes/")
;;
;; ;; Get your fortune
;; (rando-fortune)

;;; Code:
(require 'cl-lib)

(defvar rando-fortune-cache (make-hash-table :test 'equal)
  "A hash table that caches boundaries generated by
rando-fortune--find-boundaries for lookup by rando-fortune in a hash table.
Keys are filenames, data is a cons of (file-mtime boundaries) where
boundaries is a list of start/end points for quotes from the file.")

(defvar rando-fortune-dir-filter-pattern ".dat$"
  "Pattern used by string-match to filter out entries when rando-fortune
is given a directory and it picks a file at random from there.  Defaults
to .dat$ because this will remove strfile index files")

(defun rando-fortune--find-boundaries (filename)
  "Takes a single argument FILENAME which it presumes is a fortune type file.
Finds and returns a list of all boundaries of quotes in a fortune file, always
starts with 1 (the start of the file) and ends at where the point will match
(end-of-buffer)"

  (when (and (file-exists-p filename)
             (file-readable-p filename))
    
    (let ((boundaries '(1)))
      
      (with-temp-buffer
        (insert-file-literally filename)
        (goto-char (point-min))
        
        (while (not (eobp))
          (forward-line)
          (beginning-of-line)
          (let ((curr-line (string-trim (thing-at-point 'line))))
            (when (string-match-p "^%$" curr-line)
              ;; (message "Found '%s'" curr-line)
              (save-excursion
                (forward-line)
                (beginning-of-line)
                (setq boundaries (cons (point) boundaries))))))
        
        (end-of-buffer)
        (setq boundaries (cons (point) boundaries))
        (reverse boundaries)))))

(defun rando-fortune (&optional filename)
  "Takes an optional argument FILENAME which it presumes to be a fortune
file (i.e. a series of entries divided with lines which just
contain the single character %) if this is a directory then it will randomly
select a file from that directory (ignoring any files with the .dat suffix)

If the argument is not given it checks the variables fortune-file
then fortune-dir to try and find a location.

Reads the file, finds the locations of the entries, and choose
one at random.

If called interactively it produces this as a message and also
returns the string, if called from elisp simply returns the
string.

Caches the boundaries it finds in the rando-fortune-cache variable.

Intended for use on systems that lack a fortune(1).  if you have
a fortune binary you should use that and the fortune package,
although this package is probably faster in some situations."

  (interactive)

  ;; Blank argument try for existing variables from fortune.el
  (cond
   ((and (not filename)
         (boundp 'fortune-file)
         (file-exists-p fortune-file))
    (setq filename fortune-file))
   
   ((and (not filename)
         (boundp 'fortune-dir)
         (file-accessible-directory-p fortune-dir))
    (setq filename fortune-dir)))

  ;; If we've been given a directory choose files at random and try
  ;; and avoid any compiled .dat fortune files.
  (when (file-accessible-directory-p filename)
    (let ((file-list
           (cl-remove-if
            (lambda (fn)
              (or (string-match rando-fortune-dir-filter-pattern fn)
                  (not (file-readable-p fn))
                  (not (file-regular-p fn))))
            (directory-files filename t))))
      (setq filename (nth (random (length file-list)) file-list))))

  ;; Actually pick fortune
  (when (file-exists-p filename)
    
    (let ((boundaries nil)
          (max-number nil)
          (last-choice nil)
          (file-mtime
           (time-convert (file-attribute-modification-time
                          (file-attributes filename))
                         'integer))
          (cache-data (gethash filename rando-fortune-cache)))

      ;; (message "got cache-data '%s'" cache-data)

      (if cache-data

          ;; Fetch from cache, update if required
          (let ((cache-mtime (car cache-data)))
            (if (<= file-mtime cache-mtime)
                (progn
                  ;; (message "Loading boundaries for '%s' from cache" filename)
                  (setq boundaries (cdr cache-data)))
              
              (progn
                ;; (message "Setting boundaries for '%s' into cache '%i'" filename file-mtime)
                (setq boundaries (rando-fortune--find-boundaries filename))
                (puthash filename
                         (cons file-mtime boundaries)
                         rando-fortune-cache))))

        ;; No cache data?  Just make it fresh
        (progn
          ;; (message "No cache-data so setting boundaries for '%s' into cache '%i'" filename file-mtime)
          (setq boundaries (rando-fortune--find-boundaries filename))
          (puthash filename
                   (cons file-mtime boundaries)
                   rando-fortune-cache)))

      ;; max-number is the random number we generate up to.  Length
      ;; is 1 based, nth is 0 based, and we have the start/end
      ;; markers so remove 1 from the max-number so we never
      ;; generate the last marker as thats eobp and not a %
      ;;
      ;; last-choice is the last valid choice to make in a 0 indexed
      ;; nth call, and hence needs to be -2 to be the nth item that
      ;; actually occurs before the end.
      (setq max-number (- (length boundaries) 1))
      (setq last-choice (- (length boundaries) 2))
      
      ;; (message "got %s boundaries so generating between 0 and %i" (length boundaries) max-number)
      
      ;; (message "boundaries: %s" boundaries)

      (when (and boundaries
                 max-number
                 last-choice)
        (with-temp-buffer
          (insert-file-literally filename)
          (let* ((choice (random max-number))
                 (start (nth choice boundaries))
                 
                 ;; The last marker is the EOF exactly, otherwise its a % that
                 ;; you need to walk back over the \n of
                 (end (if (= choice last-choice)
                          (nth (+ 1 choice) boundaries)
                        (- (nth (+ 1 choice) boundaries) 2)))
                 
                 (fort (string-trim
                        (buffer-substring-no-properties start end))))
            
            (when (called-interactively-p 'any)
              (message "%s" fort))
            
            fort))))))

(provide 'rando-fortune)
